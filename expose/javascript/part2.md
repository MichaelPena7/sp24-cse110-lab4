1. Line 12 prints out i, which inherently serves as the length of the list of prices from the parameter 'prices'
2. Line 13 prints out discountedPrice, which will always be the discounted price of the last item in the 'prices' parameter, due to the value of discountedPrice being reset with each iteration.
3. Line 14 will print out finalPrice, which will always return the rounded version of discountedPrice, with it being rounded to the nearest hundredth, just like costs in real life.
4. This function returns a list called discounted, with it itself being the parameter list 'prices', except the values have been reduced by (1 - discount and rounded to the nearest hundredth. So in this case, it returns a list [50, 100, 150]
5.  Line 12 here will cause an error, because "let" results in i only existing in the scope it was called in. Since the line is outside the for-loop that i belongs to, it can not access i, and therefore is left as not defined.
6.  Line 13 will cause an error because discountedPrice is not defined here. This is most likely because "let" causes discountedPrice to only exist within the scope of the for loop, and any calls to it outside of the for loop are not valid due to this
7.  Line 14 will print out the finalPrice of 150, which represents the final discounted price of the last element in the "price" list. This is because line 14 belongs in the scope of finalPrice, and therefore can be accessed.
8.  This function will return the exact same list as mentioned for the function in questiond 1-4, where it will return the "price" list except the prices are reduced by a factor of(1-discount), rounded to the nearest hundredth. So, in the call in line 19, it will return the list [50, 100, 150]
9.  Similar to question 5, because i is defined with the use of "let", we can only access it under the scope that it was defined in. Since line 11 is outside the for loop that i is in, it can not access it, and therefore sees i as not defined.
10. Line 12 will print out the length of the parametert list "prices" as recorded at the start of the function. In this case, it will specifically print out 3.
11. Here, the function like the previous functions, returns the parameter list "prices" but with its prices reduced by factor of (1-discount). One may think this may cause an error because discountedPrice is being assigned different values, but because of "const" being used each time, it seems to rather create a whole new variable rather than using the previous discountedPrice. Therefore, the function is valid and does not produce and error.
12. (a) student.name; (b) student['Grad Year']; (c) student.greeting(); (d) student['Favorite Teacher'].name; (e) student.courseLoad[0]
13. (a) '32', it seems to have treated both as a string and concatenated them together. (b) 1, it seems to have treated both as an integer and simply performed integer subtraction (c) 3, it seems to have mapped null with 0 and simply done integer additions. (d) '3null', it seems to have treated both as strings and concatenated each other together. (e) 4, as explained in the write up, true is mapped as 1 and therefore performs integer addition (f) 0, false and null seem to both be mapped to 0, and therefore were simply treated as integers (g) '3undefined', it treated both as strings and simply concatenated both of them. (h) NaN, the subtraction forced both to be an integer, however undefined has no number mapped to it and therefore it is treated as NaN, so the entire thing returns this as well.
14. (a) true, both are treated as integers and 2 is in fact greater than 1. (b) true, because comparison of strings in JavaScript is handled by lexicographical order, rather than numerically. Therefore, the '2' is considered to be greater than the '1' in '12', so the expression is true. (c) true, both are treated as integers and 2 == 2 (d) false, the === operatior in JavaScript checks not only the equality of the objects but also the type. Since one is a string and the other is a integer, it returns false. (e) false, here both are treated as integers, and true is mapped as a 1. 1 != 2, so false is returned. (f) true, in javascript, calling Boolean(n) returns true as long as n does not equal 0, due to all numbers not 0 being considered truthy in JavaScript. Therefore, since both sides are equal to true, and are of the same type, it returns true.
15. "==" simply checks "loose equality", or in other words, only checks if the raw values are equal. This is done by JavaScript attempting to convert the two objects' types to be compatible with one another. Meanwhile, "===" checks for both the values being equal AND the type as well, without extra conversions.
16. See file
17. The result of modifyArray([1,2,3], doSomething) is [2,4,6]. This is because modifyArray takes a list and a function, iterating through the list and using each element in the list as the parameter of the parameter function, creates a new list with the return values of the function with each of the elements. In this case, doSomething returns the input multiplied by 2, so the modifyArray call will return the input list but its elements multiplied by 2.
18. See file
19. The output of the function is 1, 4, 3, 2. This is because 1 and 4 printing occur immediately, followed by 3 printing after a short delay, and then 2 after about 1000 miliseconds.